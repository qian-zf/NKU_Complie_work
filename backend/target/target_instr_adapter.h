#ifndef __BACKEND_TARGET_TARGET_INSTR_ADAPTER_H__
#define __BACKEND_TARGET_TARGET_INSTR_ADAPTER_H__

#include <backend/mir/m_block.h>
#include <backend/mir/m_instruction.h>
#include <backend/mir/m_defs.h>
#include <debug.h>
#include <deque>
#include <vector>

/*
 * TargetInstrAdapter
 *
 * ?????
 * - ???????????? MIR ????????????????????????
 * - ????????????? CFG ??????????????????/???????????????????????????? ISA??
 */
namespace BE::Targeting
{
    class TargetInstrAdapter
    {
      public:
        virtual ~TargetInstrAdapter() = default;

        // ???????????????????????????????????????????????????????????
        virtual bool isCall(BE::MInstruction* inst) const
        {
            ERROR("Using base target instruction adapter isCall method is not allowed");
        }
        // ???????????????????????
        virtual bool isReturn(BE::MInstruction* inst) const
        {
            ERROR("Using base target instruction adapter isReturn method is not allowed");
        }
        // ????????????????????
        virtual bool isUncondBranch(BE::MInstruction* inst) const
        {
            ERROR("Using base target instruction adapter isUncondBranch method is not allowed");
        }
        // ??????????????????
        virtual bool isCondBranch(BE::MInstruction* inst) const
        {
            ERROR("Using base target instruction adapter isCondBranch method is not allowed");
        }
        // ?????/????????????????????????????? ID????? inst ??????????????????? -1
        virtual int extractBranchTarget(BE::MInstruction* inst) const
        {
            ERROR("Using base target instruction adapter extractBranchTarget method is not allowed");
        }

        // ????????????????????????????????????????
        virtual void enumUses(BE::MInstruction* inst, std::vector<BE::Register>& out) const
        {
            ERROR("Using base target instruction adapter enumUses method is not allowed");
        }
        // ?????????????????????????????????????????
        virtual void enumDefs(BE::MInstruction* inst, std::vector<BE::Register>& out) const
        {
            ERROR("Using base target instruction adapter enumDefs method is not allowed");
        }

        // ?? inst ??????????????????? from ??I? to
        virtual void replaceUse(BE::MInstruction* inst, const BE::Register& from, const BE::Register& to) const
        {
            ERROR("Using base target instruction adapter replaceUse method is not allowed");
        }
        // ?? inst ?????????????i????? from ??I? to
        virtual void replaceDef(BE::MInstruction* inst, const BE::Register& from, const BE::Register& to) const
        {
            ERROR("Using base target instruction adapter replaceDef method is not allowed");
        }

        // ?????????????????MOV?????????????? true ???????????????
        virtual bool isCopy(BE::MInstruction* inst, BE::Register& dst, BE::Register& src) const
        {
             // ?????? false?????????????????
             return false;
        }

        // ???????????????????????????????+??????????????????????????
        virtual void enumPhysRegs(BE::MInstruction* inst, std::vector<BE::Register>& out) const
        {
            ERROR("Using base target instruction adapter enumPhysRegs method is not allowed");
        }

        // ?? it ???????????????????? frameIndex ????? physReg ?????reload??
        // ?? RA ??????????? use ?????
        virtual void insertReloadBefore(BE::Block* block, std::deque<BE::MInstruction*>::iterator it,
            const BE::Register& physReg, int frameIndex) const
        {
            ERROR("Using base target instruction adapter insertReloadBefore method is not allowed");
        }

        // ?? it ??????????????? physReg ??????? frameIndex ???????spill??
        // ?? RA ??????????? def ?????
        virtual void insertSpillAfter(BE::Block* block, std::deque<BE::MInstruction*>::iterator it,
            const BE::Register& physReg, int frameIndex) const
        {
            ERROR("Using base target instruction adapter insertSpillAfter method is not allowed");
        }
    };

    inline const TargetInstrAdapter* g_adapter = nullptr;
    inline void                      setTargetInstrAdapter(const TargetInstrAdapter* adapter) { g_adapter = adapter; }
}  // namespace BE::Targeting

#endif  // __BACKEND_TARGET_TARGET_INSTR_ADAPTER_H__
