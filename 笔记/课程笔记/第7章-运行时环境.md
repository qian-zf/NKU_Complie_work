---
date: 2025-12-28
---
在编译原理中，将源代码翻译成目标代码只是第一步。为了让程序真正跑起来，编译器必须为源语言构建一个能够支持其语义的**运行时环境**。这一章的核心在于探讨编译器如何在运行时管理内存，以及如何处理名字（变量、函数）的访问。

## 1. 源语言与运行时概念的映射

首先，我们需要区分“静态”和“动态”两个维度的概念。在代码文本中，我们看到的是**过程（Procedure）** 或函数定义，这是一个静态概念；而在程序运行时，每一次执行过程体都称为一次**活动（Activation）**，这是一个动态概念。

### 活动树与控制栈

程序的执行流程可以用**活动树（Activation Tree）** 来表示。

- **根节点**代表主程序的活动。
- 当过程 $P$ 调用过程 $Q$ 时，$Q$ 就成为 $P$ 的子节点。
- 节点的左右顺序代表了调用的先后时间。

为了管理这些活动，运行时环境使用**控制栈（Control Stack）**。这利用了大多数语言过程调用的“后进先出”特性：当过程被调用时，其相关信息入栈；当过程结束时，信息出栈。栈内的内容反映了当前时刻活动树中从根节点到当前节点的路径。

### 作用域与绑定

- **作用域 (Scope)**：这是一个静态概念，指变量声明在源代码中起作用的范围。
- **绑定 (Binding)**：这是一个动态概念。名字在运行时需要绑定到具体的存储位置（Storage）和值（Value）。
    - **环境 (Environment)**：将名字映射到存储位置（左值）。
    - **状态 (State)**：将存储位置映射到具体的值（右值）。

**赋值语句**改变的是状态（内存里的值），而不改变环境（变量对应的内存地址）。

---

## 2. 存储组织与布局

运行时内存通常被划分为四个主要区域，以适应不同的分配需求：

1. **代码区 (Code)**：存放编译后的目标代码，大小固定。
2. **静态数据区 (Static Data)**：存放全局变量或静态变量，编译时即可确定位置。
3. **栈区 (Stack)**：用于管理过程的活动，支持递归调用。
4. **堆区 (Heap)**：用于动态内存分配（如 `new` 或 `malloc`），或者存放生命周期超过过程活动期的数据。

### 活动记录 (Activation Record)

栈区中的基本单位是**活动记录**（也称为栈帧）。每一次函数调用都会产生一个新的活动记录，其典型结构包含：

- **返回值**：存放被调函数返回给主调函数的结果。
- **实际参数**：主调函数传递进来的参数。
- **控制链接 (Control Link)**：指向调用者（父函数）的活动记录，用于函数返回时恢复环境（也称为动态链）。
- **访问链接 (Access Link)**：用于访问非局部变量（也称为静态链）。
- **机器状态**：保存程序计数器（PC）、寄存器等硬件状态。
- **局部数据**：函数内部声明的变量。
- **临时变量**：表达式计算中的中间结果。
    

> **数据对齐**：为了硬件访问效率，编译器通常会对数据进行对齐（padding）。例如在某些机器上，`char` 后可能紧接几个字节的空白填充，以保证后续 `int` 型数据从整数倍地址开始。

---

## 3. 存储分配策略

编译器通常采用以下三种策略来管理内存：

### 3.1 静态分配 (Static Allocation)

这是早期语言（如 Fortran 77）采用的策略。所有变量的地址在编译时确定。

- **优点**：执行效率高，无需运行时管理。
- **缺点**：**不支持递归**（因为局部变量地址固定，第二次进入函数会覆盖前一次的值），也不支持动态数据结构。
    

### 3.2 栈分配 (Stack Allocation)

现代语言（C, Pascal, Java等）的主流策略。局部名字绑定到栈顶的活动记录中。

- **调用序列 (Calling Sequence)**：这是一段代码，负责在进出函数时维护栈结构。
    - **调用者**负责：计算实参、保存返回地址。
    - **被调用者**负责：保存寄存器、初始化局部变量。
    - **返回时**：恢复寄存器、移除栈帧、跳转回返回地址。
- **特点**：完美支持递归，局部变量在函数退出后自动释放。
    

### 3.3 堆分配 (Heap Allocation)

当数据的生命周期必须超过创建它的函数调用时（例如在函数内创建一个链表节点并返回其指针），必须使用堆分配。这允许程序动态申请和释放任意大小的内存，但需要处理碎片化和垃圾回收问题。

- **空悬引用 (Dangling Reference)**：如果释放了堆内存但仍保留指向它的指针，就会产生此错误。

---

## 4. 非局部名字的访问

当函数访问一个不在其内部声明的变量时，编译器如何找到这个变量？这取决于语言的作用域规则。

### 4.1 静态作用域 (Static/Lexical Scope)

大多数现代语言（Pascal, C, Ada）使用此规则。变量的作用域由代码的嵌套结构决定。

- **无嵌套过程 (如 C语言)**：非局部名字只能是全局变量，通过静态地址直接访问。
- **有嵌套过程 (如 Pascal)**：内部过程可以访问外部过程的变量。遵循“最近嵌套规则”。
    - 实现机制 - 访问链接 (Access Link)：
        - 如果过程 $P$ 嵌套在 $Q$ 中，$P$ 的活动记录中会有一个指针指向 $Q$ 的最近一次活动记录。
        - 若过程 $P$（深度 $n_p$）要访问深度为 $n_a$ 的变量 $a$，编译器会生成指令：从 $P$ 开始，沿着访问链接向上查找 $n_p - n_a$ 次，即可找到定义 $a$ 的活动记录。
    - 优化 - Display 表：
        - 为了避免沿着链表长途跋涉，可以使用一个全局数组 `d[i]`，直接指向当前活跃的、嵌套深度为 i 的过程的活动记录。
        
需要注意的是，Pascal语言所谓的“嵌套”，是将函数定义在另一个函数体内，而不是像 C 语言那样在文件级别定义多个函数。而 C 不支持这种**函数嵌套定义**。
### 4.2 动态作用域 (Dynamic Scope)

Lisp、Snobol 等语言使用。名字的绑定取决于**谁调用了当前过程**，而不是代码写在哪里。

- **示例**：如果 `Main` 定义了 `r=0.25`，`Function A` 定义了 `r=0.125`。`Main` 调用 `Function B`，`Function B` 打印 `r`。
    - 在静态作用域下，`B` 打印的是 `Main` 里的 `0.25`（假设 B 定义在 Main 中）。
    - 在动态作用域下，如果 `A` 调用了 `B`，`B` 将打印 `A` 里的 `0.125`，因为在控制栈中 `A` 是 `B` 的直接上级。
        
与Pascal不同，动态作用域下只要调用了一个过程，这个过程就可以访问上一层的变量，无论这个过程在源代码中定义在哪里。

---

## 5. 参数传递机制

函数调用时，实参（Actual Parameters）如何传递给形参（Formal Parameters）？主要有以下几种方式：

1. **传值 (Call-by-Value)**：
    - 计算实参的值（右值），拷贝到被调函数的活动记录中。
    - **特点**：函数内对形参的修改**不会**影响外部实参。C语言默认采用此方式。
    - _注_：C语言中传递指针看似改变了值，实则是传值（指针的值即地址被拷贝了），通过地址间接修改了目标。
        
2. **传地址 (Call-by-Reference)**：
    - 将实参的**地址**（左值）传递给被调函数。如果是表达式（如 `a+b`），则先存入临时位置，再传地址。
    - **特点**：形参和实参是同一个对象，修改形参即修改实参。Pascal 的 `var` 参数即为此类。
        
3. **复制-恢复 (Copy-Restore / Copy-in Copy-out)**：
    - 混合模式。调用时将实参的值拷贝给形参；函数返回时，将形参的新值**拷贝回**实参的地址。
    - 与传地址的区别：在多线程或别名（Alias）情况下，两者行为可能不同。
        
4. **传名 (Call-by-Name)**：
    - Algol 语言的特性。相当于将形参替换为实参的**文本**（类似宏替换），但在被调用的环境中执行。
    - **Jensen's Device**：这种机制极其灵活但也复杂。例如 `swap(i, a[i])` 在传名方式下可能导致非常诡异的结果，因为它实际上是在执行 `temp := i; i := a[i]; a[i] := temp;`，其中 `a[i]` 的地址会在每一行重新计算。


> [!NOTE] C语言传值的误区
> 为什么利用指针传递参数看似改变了实参的值？这是因为传递的是指针的值（地址），而不是指针本身。通过这个地址，函数可以间接访问和修改实参所指向的内存位置。因此，虽然形式上是传值，但通过指针可以实现类似传地址的效果。
> 
> 但下面的这个例子中，改变函数内指针的指向，并不会影响实参的值：

```c
void func(int* ptr) {
    int b = 50;
    ptr = &b; // 修改 ptr 本身，让它指向局部变量 b
    // 此时 func 里的 ptr 盒子里装的是 b 的地址了
}

int main() {
    int a = 10;
    int* p = &a;
    func(p);
    // 这里 p 指向的依然是 a，p 本身的值（a 的地址）完全没有被改变！
}
```

对于C++中加入的引用参数（`int&`），它实际上是传地址的一种语法糖，编译器会将其转换为指针传递，但在语法上更简洁。

---

## 6. 符号表 (Symbol Table)

符号表是编译器在编译期间和（有时）运行期间使用的核心数据结构，用于记录名字及其属性（类型、作用域、偏移量等）。

- **操作**：主要支持 `insert`（添加名字）和 `lookup`（查找名字）。
- **实现结构**：
    - **线性表**：实现简单，但查找慢（$O(n)$）。
    - **Hash表**：最常用的方式。通过哈希函数将名字映射到数组索引，冲突时使用链表解决。查找效率接近 $O(1)$。
    - 实际上我们本学期的编译项目中使用 `std::map`，其底层实现为平衡树，查找效率为 $O(\log n)$。
- **作用域处理**：
    - 当进入一个新的作用域（如 `block`）时，新声明的变量插入符号表。
    - 当退出作用域时，必须删除或隐藏该作用域内的变量，以恢复外部同名变量的可见性。实现上常使用“链表头插法”，退出时只需重置链表头指针。
        

---

## 7. 动态内存管理

对于高级语言中的堆分配（如 C++ 的 `new` 或 Java 的对象创建）：

- **显式分配**：程序员负责申请和释放（如 C 的 `malloc/free`）。容易导致内存泄漏或空悬引用。
- **隐式分配与垃圾回收 (Garbage Collection)**：
    - **引用计数**：记录指向内存块的指针数量。减为0时释放。缺点是无法处理循环引用。
    - **标记-清除 (Marking)**：从根节点（栈、全局变量）出发，遍历并标记所有可达对象。未被标记的对象即为垃圾，予以回收。
        

> [!NOTE] 循环引用是什么
> 循环引用指的是两个或多个对象互相引用，形成一个闭环，从而导致引用计数永远不为零，无法被垃圾回收机制识别为垃圾。例如对象 A 引用对象 B，B 又引用 A，即使没有其他对象引用它们，它们的引用计数也不会变为零。请看下面的例子：

```python
class Person:
    def __init__(self, name):
        self.name = name
        self.relationship = None

# 创建两个对象
father = Person("老王")
son = Person("小王")

# 建立循环引用
father.relationship = son
son.relationship = father

# 现在，我们将外部指针断开
father = None
son = None
```
例子中，`father` 和 `son` 互相引用，即使我们将外部指针断开，它们的引用计数仍然不为零，导致内存无法被释放。但这两个对象实际上已经不再被程序使用，形成了内存泄漏。


> [!NOTE] 标记清除算法示例
> 它不再数“有多少人指着我”，而是看“**我还能不能被抓到**”。在循环引用的例子中，由于外部的 `father` 和 `son` 变量已经断开了，从根集出发无法再找到“老王”或“小王”。即便它们互相拉手，也会因为**不可达（Unreachable）** 而被一并清理掉。

---

**总结**：运行时环境是连接静态代码与动态计算的桥梁。理解活动记录、栈式管理、作用域链以及参数传递的底层逻辑，对于编写高效代码和理解程序行为至关重要。