---
date: 2025-11-01
---
一般正则表达式直接转换为DFA比较困难，可以通过RE->NFA->DFA的路径实现。

## 根据RE构造NFA

- $\epsilon$ 对应的NFA：`start->(q0)->((qf))`
- 单个字符 $a$ 对应的NFA：`start->(q0)-a->((qf))`
- 连接 $R_1R_2$ 对应的NFA：将 $R_1$ 的终止状态和 $R_2$ 的初始状态串联起来
- 选择 $R_1|R_2$ 对应的NFA：新建初始状态和终止状态，由 $R_{1}$ 和 $R_{2}$ 两条路径连接
- 闭包 $R^*$ 对应的NFA：新建初始状态和终止状态，初始状态通过 $\epsilon$ 转移连接到 $R$ 的初始状态和终止状态，$R$ 的终止状态通过 $\epsilon$ 转移连接回 $R$ 的初始状态和新的终止状态

![[Pasted image 20251101220002.png]]

一个转换例子：
![[Pasted image 20251101220044.png]]
### Thompson构造法总结

核心思想：模仿正则表达式的运算：
- 连接
- 选择
- 闭包

思路：从一个个字符出发构造各自的NFA，然后逐步合并
- 每个字符对应一个简单的NFA
- 利用 $\epsilon$ 边连接，逐步合并NFA
## NFA转换为DFA

**例子：**
![[Pasted image 20251102154326.png]]
从例子中不难看出，NFA的多个状态可以对应DFA的一个状态。

**例子-带有 $\epsilon$ 的NFA转换为DFA：**
`r=0*1*2*`
![[Pasted image 20251102155024.png]]
由于ABC三个状态都可能通过 $\epsilon$ 转移到达，因此初始状态为 $\{A,B,C\}$。
- 初始状态输入0时，还是在A状态，A通过0转移到A，再对A**进行 $\epsilon$ 闭包（这很重要）**，得到 $\{A,B,C\}$。
- 初始状态输入1时，A通过1转移到BC，B通过1也可以转移到BC，C没有1的转移，因此结果为BC，再对BC进行 $\epsilon$ 闭包，得到 $\{B,C\}$。
- 初始状态输入2时，ABC都能通过2转移到C，因此结果为C，再对C进行 $\epsilon$ 闭包，得到 $\{C\}$。
- 在BC状态输入1时，B通过1转移到BC，C没有1的转移，因此结果为BC，再对BC进行 $\epsilon$ 闭包，得到 $\{B,C\}$。
- 在BC状态输入2时，B通过2转移到C，因此结果为C，再对C进行 $\epsilon$ 闭包，得到 $\{C\}$。
- 在C状态只有输入2的转移，C通过2还是C，因此结果为C，再对C进行 $\epsilon$ 闭包，得到 $\{C\}$。


### 总结 

通过转换表，就能够完成NFA到DFA的转换：
- 初始状态：NFA的初始状态的 $\epsilon$ 闭包
- 接受状态：包含NFA接受状态的DFA状态
- 转换规则：对于DFA状态中的**每个NFA状态**，计算在输入符号下的**转移**，并对结果**进行 $\epsilon$ 闭包**，得到新的DFA状态
- 重复上述过程，直到没有新的DFA状态被添加

## 最小化DFA


| 状态/输入 | 0   | 1   | 2   |
| ----- | --- | --- | --- |
| A     | B   | 空   | 空   |
| B     | 空   | D   | C   |
| C     | 空   | 空   | 空   |
| D     | 空   | E   | F   |
| E     | 空   | E   | F   |
| F     | 空   | 空   | F   |
