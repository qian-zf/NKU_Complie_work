---
date: 2025-12-28
---
### 1. 中间语言的表示形式

中间语言的设计要在“易于生成”和“易于翻译成目标代码”之间寻找平衡。常见的表示形式主要有图表示和线性表示两种。

**图表示**通常指的是语法树（Syntax Tree）或有向无环图（DAG）。语法树形象地展示了语句的层次结构，例如在处理 `a := b * -c + b * -c` 时，DAG 可以识别出公共子表达式 `b * -c`，从而避免重复计算，比普通语法树更紧凑。

**线性表示**则更接近汇编代码，其中最核心的形式是**三地址码（Three-Address Code, TAC）**。

#### 三地址码详解

三地址码是编译器后端最常用的中间形式。它的基本指令格式为 $x := y \ op \ z$，意味着一条指令最多包含三个地址（两个操作数和一个结果）。这种格式不仅能表示二元运算，还能通过变体表示一元运算（$x := \ op \ y$）、复制（$x := y$）以及无条件或条件跳转（`goto L`, `if x relop y goto L`）。

在计算机内部，三地址码通常有三种实现方式：

1. **四元式（Quadruples）：** 结构为 `(op, arg1, arg2, result)`。这种格式直观且易于重排，但如果移动指令，需要修改相关的临时变量。
    
2. **三元式（Triples）：** 结构为 `(op, arg1, arg2)`。它不显式定义结果变量，而是用三元式的索引（即第几条指令）来代表结果。这种方式节省空间，但给代码优化（指令移动）带来了很大困难，因为移动一条指令会改变其索引，导致所有引用该索引的地方都需要修改。
    
3. **间接三元式：** 通过一个额外的指针数组来指向三元式表。重排指令时只需交换指针，不需要移动实际的三元式内容，结合了前两者的优点。
    

---

### 2. 声明语句的翻译与符号表

在处理变量声明（如 `int a;` 或 `float b[10];`）时，编译器并不会生成可执行代码，而是会在**符号表**中记录信息。编译器通过维护一个`offset`（偏移量）变量，来计算每个变量在内存中的相对位置。

- **基本类型：** `char` 宽度为1，`integer` 宽度为4。
- **数组类型：** 宽度 = 元素个数 $\times$ 元素宽度。
- **指针与记录：** 指针通常固定为4字节；记录（Record/Struct）则需要单独的符号表来维护其内部字段的偏移。
    

**作用域（Scope）的处理**是通过符号表栈来实现的。每进入一个新的作用域（如函数定义或新的块），就压入一个新的符号表；退出时则弹出。这确保了局部变量能正确屏蔽外部同名变量，并且在退出作用域后释放相关资源。

---

### 3. 赋值语句的翻译

赋值语句 $S \to id := E$ 的翻译核心在于表达式 $E$ 的计算。编译器会为每个子表达式生成一个新的临时变量（如 $t_1, t_2$）来存放结果。

#### 临时变量的复用

如果完全为每个中间结果分配新的临时变量，会造成巨大的空间浪费。通过分析变量的生存周期（Liveness），我们可以复用临时变量。例如，计算 $x = a * b + c * d$：

1. 计算 $a * b$ 存入 $t_0$。
2. 计算 $c * d$ 存入 $t_1$。
3. 计算 $t_0 + t_1$，此时 $t_0$ 和 $t_1$ 作为操作数，其使命已完成，结果可以存回 $t_0$ 中，从而节省了寄存器或内存空间。

#### 数组元素的寻址

数组引用的翻译是赋值语句中的难点，尤其是多维数组。

- 一维数组 $A[i]$ 的地址计算公式为：
    $$base + (i - low) \times w$$
    展开后可分为运行时计算部分 $i \times w$ 和编译时常量部分 $(base - low \times w)$。
    
- 多维数组（以二维为例，行主序）$A[i_1, i_2]$ 的地址计算逻辑是先找到第 $i_1$ 行的起始位置，再找第 $i_2$ 列。假设 $n_2$ 是第二维的长度，公式为：
    $$base + ((i_1 - low_1) \times n_2 + (i_2 - low_2)) \times w$$
    
    这可以推广到 $k$ 维数组，本质上是多项式求值（霍纳法则）的应用。
    

---

### 4. 布尔表达式与控制流

布尔表达式在编程语言中有两个作用：一是计算逻辑值（如 `flag = a > b`），二是用于控制流分支（如 `if (a > b)`）。因此，翻译也有两种主要策略。

1. **数值表示法：** 像 C 语言一样，用 `1` 表示真，`0` 表示假。这需要生成完整的计算代码。
2. **控制流表示法（跳转法）：** 不计算具体的值，而是根据真假跳转到不同的代码位置。例如 `a < b or c < d` 会被翻译成级联的跳转指令。
    
#### Backpatching（回填）技术

在生成控制流代码（如 if-then-else 或 while）时，经常面临一个问题：生成跳转指令时，跳转的目标标号（Label）通常还未生成（因为目标代码在后面）。

Backpatching 解决了这个问题。编译器在生成跳转指令时，暂时将目标地址留空，并将这些指令的索引保存在一个链表（List）中（如 truelist 或 falselist）。当目标代码的位置最终确定时（例如处理完 else 块后，知道了出口在哪里），再回过头将正确的地址“填”入之前留空的指令中。

例如，在翻译 `while E do S1` 时：

- $E$ 的 `truelist` 回填为 $S_1$ 的起始地址。
- $E$ 的 `falselist` 回填为循环结束后的第一条指令地址。
- $S_1$ 执行完后，必须生成一条 `goto` 指令跳回 $E$ 的开始处。
    

---

### 5. 高级控制结构

#### Case/Switch 语句

`switch` 语句的翻译取决于 case 值的分布情况。

- 如果 case 值稀疏或较少，通常翻译成一连串的 `if (t == V1) goto L1` ... `else goto default` 结构。
- 如果 case 值密集（如 1, 2, 3, 4...），则使用**跳转表（Jump Table）**。编译器创建一个地址数组，利用表达式的值直接索引数组以获取跳转地址，实现 $O(1)$ 的时间复杂度。

#### 过程调用

过程调用涉及调用者（Caller）和被调用者（Callee）的配合。翻译 `call p(a, b)` 时：

1. 生成参数传递代码：通常使用 `param` 指令将参数压栈或存入队列。
2. 生成 `call` 指令：跳转到过程 $p$ 的代码段，并保存返回地址。  
3. 过程返回后，可能还需要恢复调用环境。
    

---

### 6. SSA（静态单赋值形式）

在现代编译器（如 LLVM）中，SSA 是一种非常重要的中间形式。

SSA 的核心规则是：每个变量只被赋值一次。

如果在源码中对 $x$ 赋值两次，SSA 会将其重命名为 $x_1$ 和 $x_2$。这种形式极大地简化了数据流分析，使得常量传播、死代码消除等优化算法更加高效。虽然构造 SSA（特别是处理分支汇合时的 $\phi$ 函数）比较复杂，但其带来的优化收益非常显著。