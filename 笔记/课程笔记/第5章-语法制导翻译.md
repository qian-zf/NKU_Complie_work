---
date: 2025-12-22
---
# 深入理解语法制导翻译 (Syntax-Directed Translation)

在编译原理中，语法分析仅仅是第一步。一旦我们通过语法分析构建出了程序的结构（如语法树），接下来的核心任务就是赋予这些结构以“意义”，即进行**语义分析**和**代码生成**。这一过程通常通过**语法制导翻译**（Syntax-Directed Translation, SDT）来实现。

简单来说，语法制导翻译就是将编程语言的翻译工作根据语法结构进行组织。我们为文法中的每个符号关联特定的**属性**（Attribute），并为每个产生式关联**语义规则**（Semantic Rule）。当输入串被解析成语法树时，我们通过计算这些属性来完成翻译任务。

SDT是在产生式右部嵌入**语义动作**（Semantic Actions，也就是程序片段）的一种技术手段。这些语义动作通常用来计算属性值，生成中间代码，或者构建语法树。

一个简单示例：
![[Pasted image 20251222191918.png]]
## 1. 核心概念：属性与规则

在语法制导定义（Syntax-Directed Definition, SDD）中，属性代表了翻译的结果，比如变量的数据类型、表达式的数值或者是生成的中间代码。根据属性值的流动方向，我们可以将属性分为两类：

### 综合属性 (Synthesized Attributes)

这是最直观的一种属性。一个父节点的综合属性值是根据其**子节点**的属性值计算而来的。

- **直观理解**：信息从语法树的底部向顶部流动（自底向上）。
- **典型场景**：表达式求值。例如产生式 $E \to E_1 + T$，其中 $E.val$ 的值依赖于子节点 $E_1.val$ 和 $T.val$ 的和。

### 继承属性 (Inherited Attributes)

继承属性的值来源于该节点的**父节点**或其**兄弟节点**。

- **直观理解**：信息从顶部向下或从左向右流动。
- **典型场景**：变量声明。在处理 `real x, y;` 这样的声明时，类型 `real` 是由父节点确定的，然后传递给子节点 `x` 和 `y`，使它们知道自己是实型变量。

为了直观地表示属性之间的计算依赖关系，我们通常使用**依赖图**（Dependency Graph）。如果属性 $b$ 的计算依赖于属性 $c$，则图中会有一条从 $c$ 指向 $b$ 的边。属性的计算顺序必须满足依赖图的**拓扑排序**，即在计算某个属性之前，它所依赖的所有属性都必须先计算完毕。

---

## 2. 两种关键的属性定义风格

根据文法中使用的属性类型，我们可以将语法制导定义分为两类，这对后续选择何种翻译实现方式至关重要。

### S-属性定义 (S-Attributed Definition)

如果一个语法制导定义**仅仅包含综合属性**，它就被称为 S-属性定义。

- **特点**：属性计算完全是自底向上的。
- **优势**：非常适合与 [[第4.5章-LR文法概述|LR 分析]]（自底向上分析）结合。我们可以在分析栈中保存属性值，每当进行归约时，利用栈顶元素的属性计算出左部非终结符的属性。
    

### L-属性定义 (L-Attributed Definition)

L-属性定义允许使用综合属性，也允许使用**受限的继承属性**。所谓“受限”，是指一个节点 $X_j$ 的继承属性**只能依赖于**：

1. 该产生式中 $X_j$ **左边**的符号（$X_1 \dots X_{j-1}$）的属性。
2. 产生式左部符号 $A$ 的继承属性。
    
- **特点**：属性计算可以在一次自顶向下的深度优先遍历中完成。
- **包含关系**：所有的 S-属性定义本质上也是 L-属性定义。

简单的例子：
- 文法：
```text
DeclList -> Decl DeclList 
DeclList -> ε
```
- 属性说明：
```text
DeclList.inh 表示进入该声明列表时的起始偏移（继承属性）。 
DeclList.syn 表示离开该声明列表后的偏移（综合属性）。 
Decl.inh 表示单个声明的起始偏移（继承属性）。 
Decl.size 表示单个声明占用的大小（综合属性）。 
Decl.syn 表示单个声明处理完毕后的偏移（综合属性）。
```
- 语义规则：
```text
对于DeclList -> Decl DeclList1：
Decl.inh = DeclList.inh 
Decl.offset = Decl.inh 
Decl.size = sizeof(Decl.type) （由声明类型决定） 
Decl.syn = Decl.offset + Decl.size 
DeclList1.inh = Decl.syn 
DeclList.syn = DeclList1.syn

对于DeclList -> ε：
DeclList.syn = DeclList.inh
```

（偏移就是相对基地址的距离）

需要注意的是，`Decl.syn` 虽然依赖于继承属性，但它本身是综合属性（计算过程在子树中完成），因此整个定义仍然符合 L-属性的要求。

**AI给的例子解析：**

> [!NOTE] L-属性定义示例解析
> 用自然语言说明规则：当处理一个声明列表时，DeclList 的继承属性 DeclList.inh 表示进入该列表时的当前偏移；处理第一个声明时，把这个偏移传给该声明作为 Decl.inh（这是继承属性从左部传下来的情况）；声明处理完后得到自己的综合偏移 Decl.syn（等于 Decl.inh + Decl.size），然后把这个综合偏移作为右侧子列表的继承属性 DeclList1.inh，继续处理下一个声明。最终空产生式会把当前偏移作为 DeclList.syn 传上来，表示整个列表占用到的最终偏移。
> 
> 把上面过程走一次具体数值演算：初始化 DeclList. inh = 0；第一个声明类型为 int，所以 Decl. size = 4，Decl. offset = Decl. inh = 0，Decl. syn = 0 + 4 = 4，接着把 4 传给下一个子列表的继承属性，所以下一次处理时 DeclList. inh = 4。第二个声明类型为 char，所以 Decl. offset = 4，Decl. size = 1，Decl. syn = 5，传给下一个子列表的继承属性则为 5。第三个声明类型为 double，所以 Decl. offset = 5，Decl. size = 8，Decl. syn = 13。最后碰到空产生式时，DeclList. syn = DeclList. inh（也就是 13），表示整个声明序列占用了 13 个字节（注意这里没有考虑内存对齐；如果考虑对齐，偏移计算会在每个声明前进行 align 操作，但依赖仍然只来自左侧或左部继承属性，因此仍为 L-属性情况）。

---

## 3. 构造语法树与中间表示

语法制导翻译的一个重要应用是构建**语法树**（Syntax Tree）或**抽象语法树**（AST）。这是一种压缩后的中间表示形式，去除了不必要的链式推导，将运算符和关键字作为内部节点。

### 构造方法

我们可以定义辅助函数来创建节点，例如：

- `mkleaf(id, entry)`：创建一个标识符叶子节点。
- `mknode(op, left, right)`：创建一个运算符内部节点，连接左右子树。
    

通过语法制导翻译，我们可以在解析表达式（如 $a-4+c$）时动态构建出对应的树结构。例如，遇到 $E \to E_1 + T$ 时，执行语义动作 `E.nptr = mknode('+', E1.nptr, T.nptr)`，将子树拼接起来。

### 有向无环图 (DAG)

对于包含公共子表达式的语句（如 `a+a*(b-c)+(b-c)*d`），更高效的表示是 **DAG**。构造 DAG 的方法与语法树类似，区别在于创建新节点前会先检查是否已存在相同的节点（例如具有相同的操作符和相同的左右子节点）。如果存在，则直接返回已有节点的指针，从而实现结构共享。

---

## 4. 语法制导翻译的实现策略

有了属性定义和语法树的概念，我们如何具体编写代码来执行翻译呢？这取决于我们采用的是自底向上还是自顶向下的分析方法。

### 策略一：自底向上计算 (基于 S-属性定义)

这是最简单的实现方式，通常与 **Yacc/Bison** 等工具配合。

- **机制**：使用一个扩展的分析栈，除了保存状态和文法符号外，还同步保存这些符号的属性值。
- **执行**：当分析器进行“归约”操作（Reduce）时，执行语义规则。例如，对于 $A \to XYZ$，新的属性 $A.a$ 由栈顶的 $X.x, Y.y, Z.z$ 计算得出，并将结果压入栈中代替原来的 $X, Y, Z$。
    

### 策略二：自顶向下计算 (基于 L-属性定义)

这种方式通常用于 **预测分析法**（如递归下降分析）。

- **机制**：为每个非终结符编写一个递归函数。
    
- **传值**：
    - **继承属性**作为函数的**参数**传入（父节点告诉子节点上下文）。
    - **综合属性**作为函数的**返回值**传出（子节点告诉父节点计算结果）。
        
- **难点处理（消除左递归）**：自顶向下分析要求文法无左递归。当我们把左递归文法（如 $E \to E_1 + T$）改写为右递归形式（$E \to T R, R \to + T R | \epsilon$）时，语义动作也需要相应调整。通常需要引入继承属性来传递中间计算结果（如 $R.i$），并将最终结果作为综合属性（$R.s$）向上传递。
    

### 策略三：在自底向上分析中计算 L-属性 (复杂场景)

LR 分析器本质是自底向上的，似乎很难处理继承属性（因为父节点还没构建出来）。但通过一些技巧，也可以实现 L-属性定义的计算：

1. **复用栈中的属性**：如果一个节点的继承属性来自于它左边的兄弟节点，那么这些信息其实已经存在于分析栈中了，可以直接访问。
2. **标记非终结符 (Marker Non-terminal)**：如果在移进过程中需要执行动作（而不是等到归约时），可以引入一个产生空串的标记非终结符 $M$（$M \to \epsilon$）。
    
    - 例如，将 $R \to + T \{action\} R$ 改写为 $R \to + T M R$。
    - 当分析器遇到 $M$ 时，会强制进行归约，从而执行嵌入的语义动作。这允许我们在中间步骤计算并保存属性值，供后续符号使用。
        

> [!NOTE] 与实验课联系
> 实验课代码框架是先利用Bison自底向上单独实现语法分析，得到抽象语法树（AST）后再通过根节点遍历子节点计算属性的。节点同时拥有综合属性和继承属性。这种方式类似于先构造语法树，然后通过树的遍历来计算属性值，实际上是一种变通的L-属性实现方式。因为在树的遍历过程中，父节点可以将信息传递给子节点（继承属性），子节点也可以将结果返回给父节点（综合属性）。这种方法虽然不是严格意义上的自顶向下或自底向上分析，但在实践中非常有效且易于实现。

---

## 5. 内存管理与最佳实践

在编译器设计中，属性值的存储和生命周期管理也是重要一环。

- 寄存器与栈分配：
    我们可以通过依赖图预测属性的生命周期。一旦某个属性被所有依赖它的节点消费完毕，其占用的空间（寄存器或栈槽）就可以被释放或重用。
    
- 避免属性拷贝：
    对于大型数据结构（如符号表或长字符串），频繁拷贝属性值代价高昂。如果语义规则仅仅是简单的赋值（如 $L_1.in = L.in$），我们可以通过指针操作或共享寄存器来避免物理拷贝。在栈式实现中，有时利用多栈结构或全局指针可以有效减少数据移动。
    

---
## 总结

语法制导翻译是连接程序语法结构与语义的桥梁。

- **S-属性定义** 简单且适合 LR 分析（自底向上）。
- **L-属性定义** 更灵活，支持上下文信息的传递（继承属性），适合 LL 分析（自顶向下），但也能通过标记非终结符适配 LR 分析。
- 通过构造**语法树**或 **DAG**，我们将线性的代码转化为易于后续优化和代码生成的树状或图状结构。