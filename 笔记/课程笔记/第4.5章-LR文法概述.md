---
date: 2025-11-18
---
## LR分析方法概述

LR文法是最大的、可以构造出相应移入-规约语法分析器的文法类。
- L表示从左到右扫描输入串
- R表示反向构造出一个最右推导序列

LR (k) 分析：需要向前查看 k 个符号来做出移入/规约的决定。一般情况下，k=1 就足够了。

自底向上分析的关键就是要正确识别句柄。

LR分析器通过维护一个**状态栈**来跟踪分析过程中的状态（构造一个自动机）。

通过LR分析表来指导移入和规约操作：
![[Pasted image 20251118163257.png]]
例如，输入b a b，分析过程如下：
1. 初始状态，栈为空，输入为 b a b $
2. 输入符号b，此时状态栈顶为0，查表ACTION\[0, b\]=s4，执行移入操作，状态栈为0 4
3. 输入符号a，此时状态栈顶为4，查表ACTION\[4, a\]=r3，执行规约操作，用产生式B->b替换b（即b出栈、B进栈，状态栈顶弹出4）。此时栈顶状态为0，查表GOTO\[0, B\]=2，状态栈为0 2
4. 输入符号a，此时状态栈顶为2，查表ACTION\[2, a\]=s3，执行移入操作，状态栈为0 2 3
5. 输入符号b，此时状态栈顶为3，查表ACTION\[3, b\]=s4，执行移入操作，状态栈为0 2 3 4
6. 输入符号$，此时状态栈顶为4，查表ACTION\[4, \$\]=r3，执行规约操作，用产生式B->b替换b（即b出栈、B进栈，状态栈顶弹出4）。此时栈顶状态为3，查表GOTO\[3, B\]=6，状态栈为0 2 3 6
7. 输入符号$，此时状态栈顶为6，查表ACTION\[6, \$\]=r2，执行规约操作，用产生式B->aB替换aB（即aB出栈、B进栈，状态栈顶弹出6和3）。此时栈顶状态为2，查表GOTO\[2, B\]=5，状态栈为0 2 5
8. 输入符号$，此时状态栈顶为5，查表ACTION\[5, \$\]=r1，执行规约操作，用产生式S->BB替换BB（即BB出栈、S进栈，状态栈顶弹出5和2）。此时栈顶状态为0，查表GOTO\[0, S\]=1，状态栈为0 1
9. 输入符号$，此时状态栈顶为1，查表ACTION\[1, \$\]=acc，分析成功。

可以总结一些直观的规律：
- 输入符号对应移入时，需要将该符号入栈，并根据ACTION表更新状态栈（即符号和状态一一对应）
- 输入符号对应规约时，需要将产生式右部的符号出栈、对应的状态出栈，并将产生式左部符号入栈（即完成一次替换）。再通过规约结果查找GOTO表更新状态栈。（注意此时的输入符号不入栈，仅在移入时才进栈）
- ACTION的s表示移入，数字表示状态；r表示规约，数字表示产生式；acc表示接受（分析成功）
- GOTO表用于在规约后根据当前状态和非终结符查找下一个状态。

算法流程：
![[Pasted image 20251118163226.png]]

## LR (0) 文法
### LR (0) 分析

**LR (0) 项目：**
![[Pasted image 20251118185924.png]]
就是在产生式的右部某个位置插入一个点（·）来表示分析进度。

**增广文法：**
- 在文法的开始符号 S 前添加一个新的开始符号 S'，并添加产生式 S'->S

使得文法的开始符号只有一个产生式，仅出现在一个生成式的左部，从而让分析器只有一个接受状态。

对于一个文法而言，其中可能包含多条产生式，每条产生式又有各自的数各LR0项目，这会导致总项目数量过于庞大。实际上，很多LR0项目之间是“等价”的，可以组成项目集，每个项目集对应一个自动机状态。所有项目集组成的集合称为**项目集闭包**，也成为**规范LR (0) 项目集族**。
![[Pasted image 20251118190750.png]]
如图例，“等价”只产生于**点的右部**以非终结符开头的项目，因为这些项目可以进一步展开，产生新的项目。直观上看，就相当于将非终结符展开了。例如S'->·S和S->·vI: T。

**增广文法->状态->分析表例子：**
![[Pasted image 20251118192418.png]]

思路：
- 先找出初始状态（包含增广文法的开始项目）
- 然后根据项目集中的项目，通过**点右移和闭包操作**，找出所有可能的状态转换，构造出状态转换图
- 然后将状态转换图转换为LR (0) 分析表：
	- 对于每个状态中的项目，如果**点右侧是终结符a**，则在ACTION表中添加==移入==操作
	- 如果点在产生式**右端末尾**，则在ACTION表中添加==规约==操作
	- 如果状态包含**增广文法的规约项目**，则在ACTION表中添加==接受==操作
	- 对于每个状态中的项目，如果**点右侧是非终结符A**，则在GOTO表中添加状态转换

### LR (0) 分析表构造实现

#### CLOSURE函数

懒得写了....

#### GOTO函数


这一节实际上是形式化定义，实际工程中直接调用Bison即可！如非考试需要，没必要手动实现这些算法。

---

### LR (0) 文法的局限性

**移入规约冲突**：当某个状态中既有点右侧为终结符a的项目，又有点在产生式右端末尾的项目时，就会出现移入规约冲突。

例如一个状态I包含项目：
-  `E->T·`
-  `T->T·*F`
此时对于输入符号*，既可以选择规约E->T，也可以选择移入*，导致冲突。这种情况下构造出的LR (0) 分析表无法唯一确定下一步操作，分析器无法工作。

**规约规约冲突**：当某个状态中有多个点在产生式右端末尾的项目时，就会出现规约规约冲突。

例如一个状态I包含项目：
-  `A->α·`
- `B->β·`
此时对于任何输入符号，都无法唯一确定使用产生式A->α还是B->β进行规约，导致冲突。

如果LR (0) 分析表中存在冲突，则该文法不是LR (0) 文法，无法使用LR (0) 分析方法进行语法分析。不是所有[[第2.1章-CFG上下文无关语法|上下文无关文法（CFG）]]都是LR (0) 文法。（这不是废话么?!）



