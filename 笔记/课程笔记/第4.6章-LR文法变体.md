---
date: 2025-11-18
---
很显然LR (0) 分析没有对输入进行预测，因此无法解决移入-规约冲突的问题。

## SLR 分析

SLR (Simple LR) 分析是一种改进的LR (0) 分析的方法，通过引入**FOLLOW集**来进行预测，从而解决移入-规约冲突的问题。

在遇到移入-规约冲突时，SLR 分析会检查当前输入符号是否在产生式左侧非终结符的 FOLLOW 集中。如果是，则选择规约操作；否则，选择移入操作。
![[Pasted image 20251121110208.png]]
由于规定FOLLOW集互不相交，SLR 分析能够有效地解决移入-规约冲突的问题。

如果给定的SLR分析表中不存在任何冲突，那么该文法就是SLR文法。

SLR分析存在的问题：只是简单的关联了FOLLOW集，但输入符号属于FOLLOW集只能说明规约是**可能**的，并不能保证规约是**正确**的。

实际上，可选的符号是FOLLOW集的一部分（子集），这根据节点的位置可能会导致错误的规约选择。
![[Pasted image 20251121111734.png]]
如图中例子，S->L=R中，R的后继符号是 \$，而L->\*R中，R的后继符号是=或 \$。这样就引出了LR (1) 分析。
## LR (1) 分析

将一般形式为 $[A\to \alpha \cdot \beta, a]$ 的项称为**LR (1) 项**，其中 $A\to \alpha \beta$ 是一个产生式， $a$ 是一个**向前看符号**（终结符），它表示在当前状态下A后面要求紧跟的终结符，称为展望符（lookahead）。
- LR (1) 中的1表示每个项目包含一个向前看符号。
- 在形如 $[A\to \alpha \cdot \beta, a]$ 且 $\beta\neq\epsilon$ 的项中，向前看符号 $a$ 没有实际意义，因为在这种情况下，分析器只能执行移入操作。
- 但是在形如 $[A\to \alpha \cdot , a]$ 的项中，向前看符号 $a$ 非常重要，因为它决定了是否可以对A进行规约操作，只有在下一个输入符号与向前看符号 $a$ 匹配时，才能执行规约操作。
	- 这样的展望符a总是FOLLOW集的一部分。

与LR (0) 类似，LR (1) 项目也存在**等价项**的问题：
- 两个LR (1) 项 $[A\to \alpha \cdot B\beta, a]$，若有 $B\to \gamma \in P$，则可推出 $[B\to \cdot \gamma, b]$，其中 $b\in FIRST(\beta a)$。
- 当 $\beta\implies^*\epsilon$ 时，$b=a$ 称为**继承**的后继符，否则称为**自生**的后继符。
- 从直观上理解，两个项目都表示在相同的状态下，期望看到相同的输入符号，因此它们是等价的。若 $\beta$ 可以为空，则 $a$ 也会被B的产生式期待。（若点后是终结符，则该终结符的产生式搭配一个展望符就是当前项目的等价项目：如果这个终结符后为空，搭配的展望符就是原项目的展望符；否则就是其后串的First集。）
- 同一个状态的项目可能会有多个向前看符号。
- 点后不是非终结符的项目很显然没有等价项。

例子：
![[Pasted image 20251121114542.png]]
（图补全，补充I11接收\*到I11，接受id到I12）
（另外，同一个LR项目对应的LR1项目可以放在一起写，将展望符合并即可。如 $[R\to L\cdot, =/\$]$）

实际上，相比于LR (0) 分析，LR (1) 分析仅在规约项目上增加了向前看符号的判断，从而**避免了错误的规约**选择。而在移入项目上并没有区别。这可以体现在分析表中：

![[Pasted image 20251121115005.png]]

补充：如果除了展望符号不同，两个LR (1) 项目集相同，则称这两个项目集是**同心**的。（如I8和I10、I4和I11）同心项目实际上是由LR (0) 项目集分裂而来的，这就使得LR(1) 的状态数更多，有时不太实用。这就引出了LALR分析。

## LALR 分析

LALR (Look-Ahead LR) 分析是一种介于SLR和LR (1) 之间的分析方法。它通过合并具有相同LR (0) 项目集的LR (1) 项目集（即**同心项目集**）来减少状态数，从而提高分析器的效率。如果得到的LALR分析表中不存在任何冲突，那么该文法就是LALR文法。

将LR (1) 自动机中的同心项目合并后，得到下图结果：
![[Pasted image 20251121141951.png]]
因为I8与I10同心，故可以将I6接收L到达I10的边替换为I6接收L到达I8. 依次类推，就合并了同心状态。

### 合并同心项目集产生规约-规约冲突

![[Pasted image 20251121142301.png]]
不会产生移进-规约冲突：因为合并了展望符，展望符只在规约时起作用。

合并同心项目集虽然不产生冲突，但可能会推迟错误的发现

例子：
![[Pasted image 20251121143235.png]]
若将I4与I9合并，那么读入 `d$` 时不会马上报错，而是会多进行几次规约，然后才会发现错误。

### 总结

LALR (1) 形式上与LR (1) 相同
大小上与LR（0）、SLR相当
分析能力介于二者之间


## 二义性文法的 LR 分析

- 二义性文法不是LR的
- 但某些二义性文法更简短，适合语言表述和理解

需要依靠优先级和结合性来解决冲突：
![[Pasted image 20251122140916.png]]
例如栈顶为 `E+E` 时，若I7在接收 `*` ，因为 `*` 优先级高于 `+` 应当移入，进入状态5。而如果I7接收 `+` ，因为加法的左结合性，应当规约。

另一个典型的例子就是if-else的移进-规约冲突：
（这部分在上机作业中有体现，等待补充）

应该保守地使用二义性文法，并且必须在严格控制之下使用，因为稍有不慎就会导致语法分析器所识别的语言出现偏差。

## LR分析中的错误处理

语法错误的检测：
- 当LR分析器在查询分析表并发现一个报错条目时，就检测到了一个语法错误

错误恢复策略：
- 恐慌模式错误恢复
- 短语层次错误恢复