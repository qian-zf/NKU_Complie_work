---
date: 2025-11-01
---
有穷自动机（FA）是对一类处理系统建立的数学模型，具有一系列离散的输入输出信息和有穷数目的内部状态（状态：概括了系统在某一时刻的全部信息）。

有穷自动机可以用来描述和分析计算机程序、数字电路、通信协议等各种系统的行为。只需要知道系统的当前状态和输入，就可以确定系统的下一个状态和输出。

## 转换图

节点：FA的状态
- 初始状态：只有一个
- 终止状态：可以有多个
带标记的有向边：输入引发的状态转移

![[Pasted image 20251101205202.png]]
## FA定义（接收）的语言

给定输入串 $x$，FA从初始状态出发，按输入串的符号依次进行状态转换，直到输入串全部读完。如果此时FA处于**终止状态**，则称FA**接受**该输入串 $x$，否则称FA**不接受**该输入串 $x$。

由一个FA（$M$）接受的所有输入串组成的集合称为该FA**定义的语言**，记为 $L(M)$。

例子：
![[Pasted image 20251101205456.png]]
注意，只需要要存在一种路径使FA到达终止状态即可。对于自环，能找到合适的路径即可。图中的FA定义的语言为所有以 `abb` 结尾的ab字符串。所以 `abbaabb` 可以被接受。

## 最长子串匹配原则

当FA在处理输入串时，如果存在多种可能的状态转换路径，则应选择能够匹配最长输入子串的路径。这一原则被称为**最长子串匹配原则**。

简而言之，就是在终止状态时，若输入串还未读完，则回溯到上一个终止状态（或直接继续前进），继续处理剩余输入串。

## 有穷自动机的分类

### 确定的有穷自动机 （DFA）

DFA的每个状态对于每个输入符号都有且只有一个确定的转换路径。
$$
M=(S, \Sigma, \delta, s_{0},F)
$$
- $S$：有限状态集合
- $\Sigma$：有限输入符号集合（字母表）
- $\delta$：状态转换函数，$\delta: S \times \Sigma \rightarrow S$，将 $S \times \Sigma$ 映射到 $S$ 的转换函数。从状态 $S$ 经过输入符号 $\Sigma$ 转换到下一个状态 $S$
- $s_{0}$：初始状态，$s_{0} \in S$
- $F$：终止状态集合，$F \subseteq S$

可以用状态表示意DFA：
![[Pasted image 20251101211027.png]]
### 非确定的有穷自动机 （NFA）

NFA的每个状态对于某个输入符号可以有多个转换路径，甚至没有转换路径。
$$M=(S, \Sigma, \delta, s_{0},F)$$
- $S$：有限状态集合
- $\Sigma$：有限输入符号集合（字母表）
- $\delta$：状态转换函数，$\delta: S \times \Sigma \rightarrow 2^{S}$，即对于每个状态和输入符号，可以转换到多个状态。从状态 $S$ 经过输入符号 $\Sigma$ 转换到状态集合 $2^{S}$
- $s_{0}$：初始状态，$s_{0} \in S$
- $F$：终止状态集合，$F \subseteq S$

也可以用状态表示意NFA，但是一格内可以有多个状态：
![[Pasted image 20251101211338.png]]
例如 [[#FA定义（接收）的语言]] 中的例子就是一个NFA。

#### 带有 $\epsilon$ 边的NFA

NFA可以包含一些不需要输入符号就能进行状态转换的边，称为 $\epsilon$ 边。这种NFA称为 $\epsilon$ -NFA。

直观上理解，就是状态A可以不需要任何符号就转换为状态B。

例如正则表达式 `r=1*2*3*`，由于克林闭包的存在，可以有任意多个1、2、3，所以可以设计一个 $\epsilon$ -NFA。

实际上，可以通过添加 $\epsilon$ 边来简化NFA的设计，但两者等价。
### NFA与DFA的等价性

NFA和DFA在表达能力上是等价的。也就是说，对于任何一个NFA，都存在一个等价的DFA，能够接受相同的语言，反之亦然。

一般来说NFA比DFA更直观，但计算机中DFA比NFA更易实现。

## DFA的算法实现

输入：以文件结束符eof结尾的字符串 $x$，DFA的开始状态 $s_{0}$，终止状态集合 $F$，状态转换函数 $\delta$。

输出：接受或不接受 $x$。

伪代码：
```
s = s0
x = nextChar()
while x not eof do
		s = delta(s, x)  # 状态转换
		x = nextChar()
end while
if s in F return "yes"
else return "no"
```
