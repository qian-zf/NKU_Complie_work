---
date: 2025-12-22
---
# 深入理解类型检查 (Type Checking)

在编译器的架构中，**类型检查**位于语法分析（Parsing）之后，中间代码生成之前。它的核心任务是确保程序的“语义”正确性。简单来说，语法分析器保证了你写的句子符合语法结构（主谓宾正确），而类型检查器则确保这个句子是有意义的（例如，你不能把“桌子”和“昨天”这两个词相加）。

## 1. 类型系统 (Type System)

类型系统是一套规则集合，用于给程序的各个组成部分（变量、表达式、函数等）赋予类型。它是编译器中最“铁面无私”的法官。

### 类型表达式

我们在代码中看到的类型，在编译器内部被称为**类型表达式**。它可以分为两类：

1. **基本类型**：语言原生支持的原子类型，如 `boolean`, `char`, `integer`, `real`，以及特殊的 `type_error`（出错时使用）和 `void`（无值）。
    
2. **构造类型**：通过**类型构造符**将基本类型组合而成。常见的构造方式包括：
    
    - **数组 (Array)**：`array(I, T)`，表示索引范围为 $I$，元素类型为 $T$。
    - **笛卡尔积 (Product)**：$T1 \times T2$，常用于函数参数列表。
    - **记录 (Record)**：类似结构体，带有域名的元组。
    - **指针 (Pointer)**：`pointer(T)`，指向类型 $T$ 的对象。
    - **函数 (Function)**：$D \to R$，表示从定义域类型 $D$ 到值域类型 $R$ 的映射。
        

类型系统可以是**静态**的（编译时检查，如 C++、Java），也可以是**动态**的（运行时检查，如 Python、JS）。静态类型检查能更早发现错误，并在生成代码时利用类型信息进行优化。

---

## 2. 简单的类型检查器实现

一个基础的类型检查器通常通过**语法制导翻译**来实现。我们在遍历语法树时，计算每个节点的类型属性。

### 声明与符号表

当编译器遇到 `id : T` 这样的声明时，会将标识符 `id` 和类型 `T` 绑定并存入**符号表**。后续遇到该标识符时，直接查表获取其类型。

### 表达式检查规则

编译器通过比对操作符和操作数的类型来工作。例如：

- **取模运算 (`mod`)**：左右操作数必须都是 `integer`，结果也是 `integer`。否则报 `type_error`。
- **数组访问 (`E1[E2]`)**：索引 `E2` 必须是 `integer`，且 `E1` 必须是数组类型 `array(s, t)`。结果类型为 `t`。
- **指针解引用 (`E^` 或 `*E`)**：`E` 必须是 `pointer(t)` 类型，结果类型为 `t`。
    

### 语句检查规则

语句通常没有“值”，所以其类型往往是 `void`，如果出错则为 `type_error`。

- **赋值 (`x := E`)**：检查变量 `x` 的类型是否与表达式 `E` 的类型一致。
- **条件跳转 (`if E then S`)**：表达式 `E` 的类型必须是 `boolean`。
- **循环 (`while E do S`)**：同样要求控制表达式 `E` 为 `boolean`。
    

---

## 3. 类型表达式的等价 (Type Equivalence)

当我们在代码中写 `x = y` 时，编译器如何判断 `x` 和 `y` 的类型是否“相同”？这里有两种主要的判定标准：

### 结构等价 (Structural Equivalence)

这是最直观的标准。如果两个类型表达式在**结构上完全一致**（即它们的语法树或类型图形状相同，且对应节点的基本类型相同），则认为它们等价。

- 例如：`array(1..10, int)` 和 `array(1..10, int)` 是结构等价的。
    
- **算法逻辑**：递归比较。如果是基本类型，直接比；如果是数组，比索引范围和元素类型；如果是指针，比指向的类型。
    

### 名字等价 (Name Equivalence)

这种标准更严格。两个类型变量被认为是等价的，当且仅当它们由完全相同的**类型名**定义。

- 例子：Delphi
    ```
    type Link = ^Cell;
    var a, b : Link;
    var c : ^Cell;
    ```
    
    在名字等价下，`a` 和 `b` 类型相同（都是 `Link`），但 `a` 和 `c` 类型不同（一个是 `Link`，一个是匿名指针），尽管它们底层结构一样。
    
- **回路问题**：在处理链表等递归数据结构（如 `struct Node { Node* next; }`）时，**结构等价会陷入无限递归（回路）**。C 语言通过要求结构体使用**名字等价**来避免这个问题——只有名字相同的结构体才被视为同一类型。
    

---

## 4. 类型转换与重载

### 类型转换 (Type Conversion)

当操作数类型不匹配但兼容时（如 `float + int`），编译器会进行转换。

- **隐式转换 (Coercion)**：编译器自动完成，通常是从低精度向高精度转换（如 int 转 real），保证信息不丢失。
- **显式转换 (Explicit Casting)**：程序员强制指定，如 C 语言中的 `(float)10`。
    

### 函数与操作符重载 (Overloading)

重载是指同一个符号（如 `+`）或函数名在不同上下文中有不同含义。

- **解析过程**：表达式 `E1(E2)`可能有多种类型组合。编译器需要计算子表达式的**可能类型集合**，然后自顶向下或自底向上筛选出唯一合法的解释。如果找不到或找到多个，则报错。
    

---

## 5. 多态函数 (Polymorphic Functions)

普通函数要求参数类型固定，而多态函数允许参数类型在调用时发生变化。例如，一个计算列表长度的函数 `length` 应该能处理 `list(int)`，也能处理 `list(char)`。

### 类型变量

为了处理多态，我们要引入**类型变量**（通常用希腊字母 $\alpha, \beta$ 表示）。

- 对于 `length` 函数，其类型可以表示为 `list`($\alpha$) $\to$ `integer`。这里的 $\alpha$ 是一个占位符，代表“任意类型”。
    

### 类型推断 (Type Inference)

在像Python这样的语言中，你不需要显式声明变量类型，编译器会自动推导。

- 推导逻辑：如果我们看到表达式 `p(lptr)`，且 `p` 的类型未知。一旦发现 `p` 接受了 `lptr`（假设是 `link` 类型），我们就可以推断出 `p` 的参数类型必须是 `link`。
    

---

### 合一算法 (Unification)

在处理多态和类型推断时，核心操作不是简单的“比较相等”，而是**合一 (Unify)**。

#### 什么是合一？

给定两个包含类型变量的表达式 $s$ 和 $t$，合一就是寻找一个**代换 (Substitution)** $S$，使得 $S(s) = S(t)$。

- 如果 $s = \text{pointer}(\alpha)$ 且 $t = \text{pointer}(\text{int})$，我们可以用 $\text{int}$ 代换 $\alpha$，使得两者相等。
- 我们的目标是找到**最一般合一代换 (Most General Unifier, MGU)**，即限制最少的代换。
    

#### 算法流程 (基于图论)

合一算法通常使用**类型图**和[[8.集合及其运算#并查集模板|并查集]] (Union-Find) 数据结构来实现。

1. **节点代表**：每个类型表达式是一个图节点。我们维护一个集合，集合中的节点是等价的。
2. **递归检查**：
    - `unify(m, n)`：首先找到 $m$ 和 $n$ 所在集合的代表节点 $s$ 和 $t$。
    - 如果 $s = t$，已经等价，返回 true。
    - 如果 $s$ 和 $t$ 都是操作符节点（如都是 `pointer`），则将它们所在的集合**合并 (Union)**，然后递归地 `unify` 它们的子节点。
    - 如果其中一个是**类型变量**，则将该变量所在的集合与另一个节点所在的集合合并。这样，该变量就被“绑定”到了具体类型上。
        

#### 举例

假设我们要合一 `list`($\alpha$) 和 `list`(`int`)：

1. 根节点都是 `list`，匹配。
2. 递归合一子节点：$\alpha$ 和 `int`。
3. $\alpha$ 是变量，`int` 是基本类型。我们将 $\alpha$ 指向 `int`。
4. 合一成功。此后，所有出现 $\alpha$ 的地方都被视为 `int`。
    

---

**总结**：类型检查是编译器保证程序“言之有物”的关键步骤。从简单的静态检查规则，到处理复杂数据结构的类型等价性，再到支持现代语言特性的多态推导与合一算法，类型系统构成了程序语言安全性和表达力的基石。